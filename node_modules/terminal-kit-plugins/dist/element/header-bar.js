"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Util = __importStar(require("util"));
const events_1 = require("events");
function HeaderBarFactory(terminal, options) {
    return new HeaderBar(terminal, options);
}
exports.HeaderBarFactory = HeaderBarFactory;
class HeaderBarEvents {
}
HeaderBarEvents.SELECTED = 'selected';
exports.HeaderBarEvents = HeaderBarEvents;
class HeaderBar {
    constructor(term, options) {
        this._eventEmitter = new events_1.EventEmitter();
        this._terminal = term;
        this._onKeyEvent = this._onKey.bind(this);
        this._items = [];
        options.x = options.x || 0;
        options.y = options.y || 0;
        options.width = options.width || this._terminal.width;
        options.style = options.style || this._terminal.noFormat;
        options.divider = options.divider || '|';
        options.padding = options.padding || 1;
        options.dividerStyle = options.dividerStyle || options.style;
        this._options = options;
        this.focus();
    }
    abort() {
        this.blur();
    }
    focus() {
        this._terminal.on('key', this._onKeyEvent);
    }
    blur() {
        this._terminal.off('key', this._onKeyEvent);
    }
    add(object) {
        this._items.push(object);
        return this;
    }
    redraw() {
        const menuItems = [];
        this._items.map((item) => {
            menuItems.push({
                label: this._getLabel(item),
                key: this._getKey(item),
            });
        });
        this._terminal.moveTo(this._options.x, this._options.y);
        let lineLen = 0;
        const style = this._options.style || this._terminal.noFormat;
        const dividerStyle = this._options.dividerStyle || style;
        menuItems.forEach((item) => {
            const str = Util.format(' [%s] %s ', item.key, item.label);
            lineLen += str.length;
            style(str);
            dividerStyle(this._options.divider);
            lineLen += String(this._options.divider).length;
        });
        const fill = this._terminal.width - lineLen;
        style(String('').padEnd(fill, ' '));
    }
    on(event, listener) {
        this._eventEmitter.on(event, listener);
        return this;
    }
    _onKey(key) {
        const found = this._items.find((item) => {
            const itemKey = this._getKey(item);
            if (key === itemKey) {
                return item;
            }
        });
        if (found === undefined) {
            return;
        }
        this._eventEmitter.emit(HeaderBarEvents.SELECTED, found);
    }
    _getKey(item) {
        if (typeof this._options.getKey === 'function') {
            return this._options.getKey(item);
        }
        else if (typeof this._options.getKey === 'string') {
            return item[this._options.getKey];
        }
        else {
            throw new Error('GetKey option ("getKey") was not set for Header Bar element.');
        }
    }
    _getLabel(item) {
        if (typeof this._options.get === 'function') {
            return this._options.get(item);
        }
        else if (typeof this._options.get === 'string') {
            return item[this._options.get];
        }
        else if (typeof item._toString === 'function') {
            return String(item);
        }
        else {
            throw new Error('Getter option ("get") was not set for Header Bar element.');
        }
    }
}
exports.HeaderBar = HeaderBar;
